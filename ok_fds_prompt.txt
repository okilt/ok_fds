I want to create a Python project called OKFundDataSystem. Below is the overview and details of the system. Please read and understand all the details carefully, and help generate consistent and perfect Python codes for the project. For class names, function names, comments and etc. generations, please use British English. Please don't generate anything yet and please let me know if you have complete information to start generating codes. If you have any questions, please let me know. If you are good, please generate codes file by file.

System Overview

OKFundDataSystem is a sophisticated financial data management system designed for investment funds. It provides a unified interface for accessing, caching, and processing fund and market data from multiple sources. The system features advanced caching with dependency tracking, concurrent request handling, and intelligent invalidation strategies.

Project Structure

src/
│   __init__.py
│
├───cache/
│       cache_invalidation.py - Handles intelligent cache invalidation strategies
│       cache_key.py - Generates consistent cache keys for various inputs
│       cache_manager.py - Manages caching of data with various strategies
│       distributed_cache.py - Implements multi-level caching (memory, Redis and disk)
│       request_registry.py - Tracks in-flight requests to prevent duplicates
│       __init__.py
│
├───data_providers/
│   │   base_provider.py - Base class for all data providers
│   │   data_provider.py - Top-level coordinator for all data access
│   │   dependency_resolver.py - Resolves data dependencies for various functions
│   │   __init__.py
│   │
│   ├───fund_data/
│   │       fund_data_manager.py - Coordinates access to fund data providers
│   │       api_provider.py - Provider for API fund data access
│   │       sql_provider.py - Provider for SQL Server fund data access using turbodbc
│   │       __init__.py
│   │
│   └───market_data/
│           bloomberg_provider.py - Provider for Bloomberg market data
│           market_data_manager.py - Coordinates access to market data providers
│           wrapper_provider.py - Provider for market data through another library
│           __init__.py
│
├───fund/
│   │   base_fund.py - Abstract base class for all fund implementations
│   │   fund_factory.py - Factory for creating and managing fund instances
│   │   fund_registry.py - Registry for fund .py and .yaml files and mappings to fund IDs
│   │   __init__.py
│   │
│   └───fund_files/
│           japan_fund.py - Concrete implementation of Base Fund for Japanese funds
│           __init__.py
│
└───utils/
          async_utils.py - Utilities for asynchronous operations
          concurrency_utils.py - Manages thread/process pools and concurrency limits
          context_utils.py - Provides thread -local and global context management
          dataframe_utils.py - Utilities for various DataFrame manipulations
          dependency_utils.py - Tracks dependencies between data components
          __init__.py


Core Components

1. Data Provider Layer
The data provider layer is responsible for retrieving data from various sources and presenting it through a unified interface.
DataProvider (data_provider.py): The central coordinator that routes requests to appropriate providers.
BaseProvider (base_provider.py): Abstract base class defining the interface for all data providers.
FundDataManager (fund_data_manager.py): Manages data source specific data providers (API, SQL server and etc.).
MarketDataManager (market_data_manager.py): Manages market data providers (Bloomberg and etc.).

2. Fund Layer
The fund layer represents investment funds and their operations.
BaseFund (base_fund.py): Abstract base class for all fund implementations.
FundFactory (fund_factory.py): Creates fund instances based on fund type and ID.
FundRegistry (fund_registry.py): Maps fund IDs to their .py and .yaml files and maintains fund metadata.
JapanFund (japan_fund.py): Concrete implementation for Japanese funds, which can be inherited as a parent class in individual funds' implementations.

3. Caching System
The caching system optimizes performance by storing frequently accessed data and tracking dependencies.
CacheManager (cache_manager.py): Central manager for all caching operations.
DistributedCache (distributed_cache.py): Implements multi-level caching (memory, Redis and disk).
CacheKey (cache_key.py): Generates consistent, hashable keys for cache entries.
RequestRegistry (request_registry.py): Tracks in-flight requests to prevent duplicate processing.
CacheInvalidator (cache_invalidation.py): Manages intelligent invalidation of cache entries.

4. Dependency Management
The dependency management system tracks relationships between data requests and ensures consistency.
DependencyResolver (dependency_resolver.py): Resolves dependencies between data requests.
Dependency Tracker (dependency_utils.py): Tracks dependencies between functions and data.
DependencyContext (dependency_utils.py): Context manager for tracking dependencies within a code block.

5. Utility Layer
The utility layer provides support functions for the rest of the system.
AsyncUtils (async_utils.py): Utilities for asynchronous operations.
ConcurrencyUtils (concurrency_utils.py): Manages thread/process pools and concurrency limits.
ContextUtils (context_utils.py): Provides thread -local and global context management.
DataFrameUtils (dataframe_utils.py): Utilities for various DataFrame manipulations.

Key Design Patterns

Singleton Pattern: Used for managers and registries (CacheManager, FundRegistry, etc.)
Factory Pattern: Used for creating fund instances (Fund Factory)
Strategy Pattern: Used for cache invalidation strategies
Decorator Pattern: Used for dependency tracking and caching
Repository Pattern: Used for data access abstraction
Circuit Breaker Pattern: Used for handling external service failures

Core Workflows

Data Request Flow
Client requests data through DataProvider
DataProvider routes request to appropriate manager (FundDataManager or MarketDataManager) Manager selects the appropriate provider based on data type
Before executing the request, system checks cache via CacheManager
If data is in cache and valid, it's returned immediately
If not in cache, RequestRegistry checks if the same request is already in flight
If request is in flight, client waits for the original request to complete
If not in flight, provider executes the request and result is cached
Dependencies are tracked for future cache invalidation

Cache Invalidation Flow
When source data changes, CacheInvalidator is notified
CacheInvalidator determines which cache entries depend on the changed data
Dependent entries are invalidated recursively
Next time the data is requested, it will be recalculated with fresh source data

Technical Implementation Details
Asynchronous Design: The system uses asyncio for non-blocking operations
Multi-level Caching: In-memory, Redis, and disk-based caching with fallback mechanisms
Distributed Locking: Redis-based locks for coordination across processes
Circuit Breaker: Prevents cascading failures when external services are unavailable
Dependency Tracking: Sophisticated tracking of data dependencies for precise cache invalidation
Thread Safety: Context management ensures thread safety in multi-threaded environments
Performance Monitoring: Comprehensive metrics collection for system monitoring

Integration Points
External Data Sources: Bloomberg API, various API, various SQL Server
Caching Infrastructure: Redis for distributed caching
Computational Libraries: Pandas for data manipulation, NumPy for numerical operations


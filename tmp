# bloomberg_wrapper.py (relevant parts)

import blpapi
import asyncio
import logging
from datetime import datetime, date, time, timezone
import pytz
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type, RetryError, before_sleep_log
from typing import Any, List, Dict, Optional, Callable, Tuple, Union, Literal
import time as monotime

# ... (Keep your existing constants, exceptions, _run_async_from_sync, _element_generator) ...

logger = logging.getLogger(__name__)

# Constants for lightweight network test (if not already defined globally)
_APIFLDS_SVC_URI = "//blp/apiflds"
_FIELD_SEARCH_REQUEST_NAME = blpapi.Name("FieldSearchRequest") # Renamed to avoid conflict
_FIELD_RESPONSE_NAME = blpapi.Name("FieldResponse") # For FieldSearch response

# Session Test Modes
SessionTestMode = Literal["TIMESTAMP", "LOCAL_STATE", "NETWORK_LIGHT"]


class BloombergAPIWrapper:
    def __init__(self,
                 connection_pool_manager: Any,
                 host: str = 'localhost',
                 port: int = 8194,
                 request_timeout_ms: int = 30000,
                 session_startup_timeout_ms: int = 15000,
                 service_open_timeout_ms: int = 10000,
                 max_retries: int = 3,
                 retry_wait_base_secs: int = 2,
                 auth_options: Optional[str] = None,
                 session_activity_test_threshold_sec: float = 0.5,
                 session_test_mode: SessionTestMode = "LOCAL_STATE", # Default to local_state
                 # Timeout specifically for the network part of _test_blp_session
                 session_network_test_timeout_ms: int = 300): # Aggressive timeout for test
        self.pool_manager = connection_pool_manager
        self.connection_params = {'host': host, 'port': port}
        self.request_timeout_ms = request_timeout_ms
        self.session_startup_timeout_ms = session_startup_timeout_ms
        self.service_open_timeout_ms = service_open_timeout_ms
        self.auth_options = auth_options
        self.session_activity_test_threshold_sec = session_activity_test_threshold_sec
        self.session_test_mode = session_test_mode
        self.session_network_test_timeout_ms = session_network_test_timeout_ms

        self.retry_decorator = retry(
            # ... (retry config unchanged) ...
        )
        logger.info(f"BloombergAPIWrapper initialized with session_test_mode='{self.session_test_mode}', "
                    f"activity_threshold={self.session_activity_test_threshold_sec}s, "
                    f"network_test_timeout={self.session_network_test_timeout_ms}ms")

    # ... (_wait_for_session_event, _authorize_session, _create_blp_session unchanged from previous good version) ...
    # Ensure _create_blp_session sets _last_successful_request_time

    async def _test_blp_session_network_light(self, session: blpapi.Session) -> bool:
        """
        Performs a lightweight network test (FieldSearchRequest).
        This is meant to be called only if other faster checks fail.
        Has its own aggressive timeout.
        """
        cid = None
        test_passed = False
        # Use self.session_network_test_timeout_ms
        loop = asyncio.get_event_loop()
        overall_test_end_time = loop.time() + self.session_network_test_timeout_ms / 1000.0

        try:
            logger.debug(f"Session test (NETWORK_LIGHT): Attempting for session {session}")

            # Phase 1: Open //blp/apiflds service if not already open
            # Use a portion of the overall test timeout for this.
            service_open_timeout_s = self.session_network_test_timeout_ms / 2000.0 # e.g., 150ms if total is 300ms
            
            # Check if service is already open to avoid unnecessary blocking openService call
            # This is a quick local check.
            is_apiflds_open = _APIFLDS_SVC_URI in session.getOpenServices()

            if not is_apiflds_open:
                logger.debug(f"Session test (NETWORK_LIGHT): {_APIFLDS_SVC_URI} not open, attempting to open.")
                open_service_task = asyncio.to_thread(session.openService, _APIFLDS_SVC_URI)
                try:
                    await asyncio.wait_for(open_service_task, timeout=service_open_timeout_s)
                    logger.debug(f"Session test (NETWORK_LIGHT): {_APIFLDS_SVC_URI} opened successfully.")
                except asyncio.TimeoutError:
                    logger.warning(f"Session test (NETWORK_LIGHT): Timeout opening {_APIFLDS_SVC_URI} for session {session}.")
                    return False # Fail test if service open times out
                except blpapi.Exception as e:
                    logger.warning(f"Session test (NETWORK_LIGHT): Failed to open {_APIFLDS_SVC_URI} for session {session}: {e}")
                    return False # Fail test if service open fails
            else:
                logger.debug(f"Session test (NETWORK_LIGHT): {_APIFLDS_SVC_URI} already open.")


            service = session.getService(_APIFLDS_SVC_URI) # Should exist now
            if not service: # Should not happen if openService succeeded
                logger.error(f"Session test (NETWORK_LIGHT): Service {_APIFLDS_SVC_URI} not available after open.")
                return False

            request = service.createRequest(_FIELD_SEARCH_REQUEST_NAME.string())
            request.set("searchSpec", "PX_LAST") # Common field
            request.set("includeFieldInfo", False) # Minimal data

            cid = blpapi.CorrelationId(f"test_net_{int(monotime.monotonic()*1000000)}")
            identity = getattr(session, 'blpapi_identity', None)

            logger.debug(f"Session test (NETWORK_LIGHT): Sending FieldSearchRequest CID {cid.value()}")
            send_task = asyncio.to_thread(session.sendRequest, request,
                                          identity=identity if identity else None,
                                          correlationId=cid)
            await asyncio.wait_for(send_task, timeout=(loop.time() + self.session_network_test_timeout_ms / 1000.0 - loop.time()))


            # Phase 2: Wait for a response
            while loop.time() < overall_test_end_time:
                remaining_event_timeout_ms = max(1, int((overall_test_end_time - loop.time()) * 1000))
                event = await asyncio.to_thread(session.nextEvent, remaining_event_timeout_ms) # Use remaining time
                
                if event.eventType() == blpapi.Event.TIMEOUT:
                    continue

                for msg in event:
                    if cid in msg.correlationIds():
                        if msg.messageType() == RESPONSE or msg.messageType() == _FIELD_RESPONSE_NAME:
                            logger.debug(f"Session test (NETWORK_LIGHT): Received response for CID {cid.value()}. PASS.")
                            test_passed = True
                            return True # Test success
                        elif msg.messageType() == REQUEST_FAILURE:
                            err_info = msg.getElement(RESPONSE_ERROR)
                            logger.warning(f"Session test (NETWORK_LIGHT): RequestFailure CID {cid.value()}: {err_info}. FAIL.")
                            return False # Test fail
                if test_passed: break # Should be caught by return True above

            if not test_passed:
                logger.warning(f"Session test (NETWORK_LIGHT): Timeout waiting for response to CID {cid.value()}. FAIL.")
            return False # Timeout for response

        except asyncio.TimeoutError: # Catches wait_for timeouts
            logger.warning(f"Session test (NETWORK_LIGHT): Operation timed out for session {session}.")
            return False
        except blpapi.Exception as e:
            logger.warning(f"Session test (NETWORK_LIGHT): BLPAPI exception for session {session}: {e}")
            return False
        except Exception as e:
            logger.error(f"Session test (NETWORK_LIGHT): Unexpected error for session {session}: {e}", exc_info=True)
            return False
        finally:
            if cid and not test_passed: # If request was sent but didn't complete successfully
                try:
                    # Cancel needs a list of CIDs
                    await asyncio.to_thread(session.cancel, [cid])
                    logger.debug(f"Session test (NETWORK_LIGHT): Cancelled test CID {cid.value()}")
                except Exception as cancel_e:
                    logger.warning(f"Session test (NETWORK_LIGHT): Error cancelling test CID {cid.value()}: {cancel_e}")


    async def _test_blp_session(self, session: blpapi.Session) -> bool:
        """
        Tests the Bloomberg session based on the configured session_test_mode.
        """
        # Tier 1: Timestamp check (always performed, super fast)
        last_success_time = getattr(session, '_last_successful_request_time', 0)
        if (monotime.monotonic() - last_success_time) < self.session_activity_test_threshold_sec:
            logger.debug(f"Session test (mode: {self.session_test_mode}): Timestamp check PASSED (recently active).")
            return True
        
        logger.debug(f"Session test (mode: {self.session_test_mode}): Timestamp check FAILED (idle > {self.session_activity_test_threshold_sec}s).")

        if self.session_test_mode == "TIMESTAMP":
            # If only timestamp mode, and it failed, then the test fails.
            return False

        # Tier 2: Local state check (getOpenServices)
        try:
            open_services = session.getOpenServices() # Fast, local, synchronous call
            if not open_services:
                # If no services are open locally, and it's not a brand new session (which timestamp would've caught),
                # this might indicate an issue or an uninitialized session from the pool.
                logger.info(f"Session test (mode: {self.session_test_mode}): LOCAL_STATE check FAILED (no open services locally).")
                if self.session_test_mode == "LOCAL_STATE":
                    return False
                # For NETWORK_LIGHT, we might still proceed to network test even if no services are locally "open",
                # as the network test will try to open //blp/apiflds.
                # However, if getOpenServices itself fails (e.g. InvalidStateException), we stop.
            else:
                 logger.debug(f"Session test (mode: {self.session_test_mode}): LOCAL_STATE check PASSED (has open services: {open_services}).")
                 if self.session_test_mode == "LOCAL_STATE":
                    return True # Passed local state, and that's the configured mode

        except blpapi.InvalidStateException as e:
            logger.warning(f"Session test (mode: {self.session_test_mode}): LOCAL_STATE check FAILED (InvalidStateException: {e}).")
            return False # Session is in a bad state, definitely fail.
        except Exception as e: # Catch other potential blpapi errors from getOpenServices
            logger.warning(f"Session test (mode: {self.session_test_mode}): LOCAL_STATE check FAILED (Exception: {e}).")
            return False

        # Tier 3: Lightweight Network Test (if configured and previous checks didn't fully pass/fail for the mode)
        if self.session_test_mode == "NETWORK_LIGHT":
            logger.debug(f"Session test (mode: {self.session_test_mode}): Proceeding to NETWORK_LIGHT check.")
            network_test_ok = await self._test_blp_session_network_light(session)
            if network_test_ok:
                # If network test passes, update activity timestamp as it was successfully used
                setattr(session, '_last_successful_request_time', monotime.monotonic())
                logger.info(f"Session test (mode: {self.session_test_mode}): NETWORK_LIGHT check PASSED.")
            else:
                logger.info(f"Session test (mode: {self.session_test_mode}): NETWORK_LIGHT check FAILED.")
            return network_test_ok
        
        # Fallback, should not be reached if logic is correct for TIMESTAMP and LOCAL_STATE modes
        # If mode was LOCAL_STATE and open_services was not empty, it would have returned True.
        # If mode was LOCAL_STATE and open_services was empty, it would have returned False.
        logger.error(f"Session test: Reached unexpected fallback in _test_blp_session for mode {self.session_test_mode}.")
        return False # Default to false if logic error

    # ... (The rest of your BloombergAPIWrapper methods, including _async_send_request,
    #      _create_blp_session, and data fetching methods, remain largely the same.
    #      Ensure _last_successful_request_time is updated in _create_blp_session
    #      and _async_send_request as in previous versions.) ...